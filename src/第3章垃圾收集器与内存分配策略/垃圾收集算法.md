# 垃圾收集算法

## 标记-清除算法

### 标记：

标记出所有需要回收的对象

### 清除：

统一回收需要回收的对象

### 不足：

- 效率问题：

- 空间问题：产生大量的不连续碎片

## 复制算法

将内存分为两块：一块用完了，把还活着的赋值到另一块上面，然后完整清除这一块
使用：IBM:分为一块大的Eden，两块小的Survivor

回收操作:
1. 将Eden和Survivor中还存活着的对象一次性复制到另一块Survivor中，最后清理掉Eden，刚使用的Survivor

### 特点：

效率高，但是浪费空间，总有一部分空出

## 标记-整理算法

类似标记清除，但不是清除，而是将还存活的对象向一端移动，而直接清除边界外的内存

## 分代收集算法(当前商业虚拟机)

把Java堆分为新生代和老年代，然后分别根据其特点进行收集

- 新生代：总有大批对象死去,只有少量对象存活->>复制算法
- 老年代：存活率高，没有额外空间给其分配担保->>标记-清理/标记整理

## HotSpot算法

### 步骤

#### 枚举根节点：

GC Roots,在枚举的时候停顿所有Java执行线程，Stop The World. 然后根据引用的位置进行枚举根节点。而引用的位置在类加载的时候，就将其引用位置保存在OopMap中。

#### 安全点(Safe Point): 

能安全进行回收的地方

设计目的：在执行的线程中，可能存在大量引用变化，而带来的结果就是OomMap的变化，所以并不是每个时候都能进行GC操作的

选定：程序是否有让程序长时间执行的特征，如指令序列复用，例如方法调用、循环跳转、异常跳转等。

问题：如何让GC发生时，让所有线程到最近安全点。

解决：

- 抢先式中断：不需要线程代码主动配合，在GC发生的时候，将所有线程全部中断，如果发现没有在安全点的线程，让其运行至最近安全点。（现在基本不采用）

- 主动式中断：GC需要中断线程的时候，不直接对线程操作，而是设置一个标志，各个线程执行的时候去轮询这个标志，发现中断标志为真的时候就自挂东南枝。 (采用中断)

#### 安全区域(Safe Region)：在一段代码片段中，引用关系不会发生变化，在这个区域中的任何地方都是GC安全的。

设计目的：对于线程处于Sleep和Block状态的时候，不能运行而不能响应JVM的中断请求，一种解决办法。

使用：
1. 线程执行到Safe Region中，首先标识自己进入Safe Region
2. JVM发起GC的时候就不用管标识为Safe Region状态的线程。
3. 线程离开Safe Region的时候，检查系统是否完成了根节点的枚举：如果完成，线程可以继续执行；如果没有完成，线程必须等待收到可以安全离开Safe Region的信号为止

通俗：Safe Region就是一个避难所，当进去了以后，boss(jvm收集器)就不看不到，但是要出来的时候，要看boss离开了没有，没有离开继续躲着，等boss走开


