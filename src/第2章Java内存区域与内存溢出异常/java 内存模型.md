# Java内存区域的模型

## 所有线程共享

- 堆
- 方法区

## 线程独享

- 虚拟机栈
- 本地方法栈
- 程序计数器

## 虚拟机外内存:直接内存

---

### 堆

#### 内容：对象的实例数据
**对象**：
1. 对象头(Mark Word)
   - 01 未锁定：对象哈希码，对象分代年龄
   - 00 轻量级锁定：指向锁记录的指针
   - 10 重量级锁定：指向重量级锁的指针
   - 11 GC标记
   - 01 可偏向：偏向线程ID,偏向时间戳，对象分代年龄

2. 实例数据：等长数据放一起
3. 字节填充：8字节对齐

**对象定位**:

1. 句柄定位：将Java堆分为句柄池与实例池(增加了一次访问次数)
2. 直接指针访问(HotSpot): 步骤:
    1. 从Java方法中的 栈帧 的 本地变量表中 找到变量的类型
    2. 如果是引用，在堆中找到对象实例数据与对象指针。
    3. 从方法区找到对象

    
#### 虚拟机运行参数：

**设置堆大小**

- -Xms20m 堆最小大小20M
- -Xmx20m 堆最大大小20M

**异常输出文件**
- -XX:+HeapDumpOnOutOfMemoryError 堆出现OOM生成dump文件

#### 异常
**OOM(OutOfMemory)**:原因：过多的对象实例  见HeapOOM 
> 爆破：创建大量实例

### 方法区(永久代)

#### 包含内容
1. 虚拟机已加载的类信息
2. 常量
3. 静态变量
4. 即时编译后的代码等数据
5. 运行时常量池

**运行时常量池**
Class文件中除了类的相应描述信息外，还有就是常量池。

#### 虚拟机运行参数

**设置方法区最大大小**
- -XX:PermSize
- -XX:MaxPermSize   

#### 异常

**OOM**: 见RuntimeConstantPoolOOM 
- 常量池过大
> 爆破:创建大量字符串常量
- 类文件过多
> 爆破:动态生成大量的类


### 虚拟机栈(线程栈帧)

#### 说明：
一个java方法就是一个栈帧

#### 栈帧：

- 局部变量表
- 操作数栈
- 动态链接
- 方法出口等

**一个方法的执行到完成：一个栈帧在虚拟机中入栈到出栈**

#### 异常

- StackOverflowError: 栈深度大于虚拟机所允许的深度           
> 爆破:无限循环递归
- OOM:虚拟机栈动态扩展时，无法申请到多余的内存
> 爆破：开启自动扩展，方法内增加数据

#### 程序计数器：没有OOM









